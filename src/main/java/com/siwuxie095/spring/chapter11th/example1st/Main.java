package com.siwuxie095.spring.chapter11th.example1st;

/**
 * @author Jiajing Li
 * @date 2021-02-24 08:13:59
 */
public class Main {

    /**
     * 使用对象-关系映射持久化数据
     *
     * 小时候，骑自行车是一件很有趣的事情，对吧？在清晨，骑车上学。放学后，游逛到朋友家。当天色渐晚之时，在父母
     * 的呼喊声中，骑车回家。那些日子真的很有意思！
     *
     * 后来，随着慢慢长大，现在所需要的不仅仅是一辆自行车了。有时，需要走很远的路去上班或需要装载一些生活用品，
     * 还有可能接送孩子去上足球课。如果生活在得克萨斯州的话，还必须需要一台空调。此时的需求超出了自行车的功能
     * 范围。
     *
     * 在数据持久化的世界中，JDBC 就像自行车。对于份内的工作，它能很好地完成并且在一些特定的场景下表现出色。
     * 但随着应用程序变得越来越复杂，对持久化的需求也变得更复杂。需要将对象的属性映射到数据库的列上，并且需要
     * 自动生成语句和查询，这样就能从无休止的问号字符串中解脱出来。此外，还需要一些更复杂的特性：
     * （1）延迟加载（Lazy loading）：随着对象关系变得越来越复杂，有时候并不希望立即获取完整的对象间关系。
     * 举一个典型的例子，假设在查询一组 PurchaseOrder 对象，而每个对象中都包含一个 LineItem 对象集合。如果
     * 只关心 PurchaseOrder 的属性，那查询出 LineItem 的数据就毫无意义。而且这可能是开销很大的操作。延迟加
     * 载允许只在需要的时候获取数据。
     * （2）预先抓取（Eager fetching）：这与延迟加载是相对的。借助于预先抓取，可以使用一个查询获取完整的关联
     * 对象。如果需要 PurchaseOrder 及其关联的 LineItem 对象，预先抓取的功能可以在一个操作中将它们全部从数
     * 据库中取出来，节省了多次查询的成本。
     * （3）级联（Cascading）：有时，更改数据库中的表会同时修改其他表。回到订购单的例子中，当删除 Order 对象
     * 时，希望同时在数据库中删除关联的 LineItem。
     *
     * 一些可用的框架提供了这样的服务，这些服务的通用名称是对象/关系映射（object-relational mapping，ORM）。
     * 在持久层使用 ORM 工具，可以节省数千行的代码和大量的开发时间。ORM 工具能够把你的注意力从容易出错的 SQL
     * 代码转向如何实现应用程序的真正需求。
     *
     * Spring 对多个持久化框架都提供了支持，包括 Hibernate、iBATIS、Java 数据对象（Java Data Objects，JDO）
     * 以及 Java 持久化 API（Java Persistence API，JPA）。与 Spring 对 JDBC 的支持那样，Spring 对 ORM
     * 框架的支持提供了与这些框架的集成点以及一些附加的服务：
     * （1）支持集成 Spring 声明式事务；
     * （2）透明的异常处理；
     * （3）线程安全的、轻量级的模板类；
     * （4）DAO 支持类；
     * （5）资源管理。
     *
     * 这里不会介绍 Spring 支持的全部 ORM 框架。其实这并不会有什么问题，因为 Spring 对不同 ORM 解决方案的
     * 支持是很相似的。一旦掌握了 Spring 对某种 ORM 框架的支持后，你可以轻松地切换到另一个框架。
     *
     * 在这里，将会看到 Spring 如何与最常用的两种 ORM 方案集成：Hibernate 和 JPA。同时还会通过 Spring
     * Data JPA 了解一下 Spring Data 项目。借助这种方式，不仅可以学习到如何借助 Spring Data JPA 移除
     * JPA Repository 中的样板式代码，还能为后续的如何将 Spring Data 用于无模式的存储打下基础。
     */
    public static void main(String[] args) {

    }

}
